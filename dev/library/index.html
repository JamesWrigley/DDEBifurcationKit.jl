<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Bifurcation Analysis of DDEs in Julia</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Bifurcation Analysis of DDEs in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Bifurcation Analysis of DDEs in Julia</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorials/tutorials/">Tutorials</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Problems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../BifProblem/">Bifurcation Problem</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Periodic Orbits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../periodicOrbit/">Introduction</a></li><li><a class="tocitem" href="../periodicOrbitCollocation/">Collocation</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Functionalities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Bifurcations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../detectionBifurcation/">Bifurcation detection (codim 1)</a></li><li><a class="tocitem" href="../codim2Continuation/">Fold / Hopf Continuation (codim 2)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Normal form</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../simplebp/">Simple branch point</a></li><li><a class="tocitem" href="../nonsimplebp/">Non-simple branch point</a></li><li><a class="tocitem" href="../simplehopf/">Simple Hopf</a></li><li><span class="tocitem">Normal form (periodic orbit)</span></li></ul></li><li><a class="tocitem" href="../branchswitching/">Branch switching</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Options</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../eigensolver/">Eigen Solvers</a></li></ul></li><li><span class="tocitem">Contributing</span></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Parameters"><span>Parameters</span></a></li><li><a class="tocitem" href="#Problems"><span>Problems</span></a></li><li><a class="tocitem" href="#Eigen-solvers"><span>Eigen solvers</span></a></li><li><a class="tocitem" href="#Branch-switching-(branch-point)"><span>Branch switching (branch point)</span></a></li><li><a class="tocitem" href="#Branch-switching-(Hopf-point)"><span>Branch switching (Hopf point)</span></a></li><li><a class="tocitem" href="#Utils-for-periodic-orbits"><span>Utils for periodic orbits</span></a></li><li><a class="tocitem" href="#Misc."><span>Misc.</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/bifurcationkit/DDEBifurcationKit.jl/blob/main/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><ul><li><a href="#Library">Library</a></li><li class="no-marker"><ul><li><a href="#Parameters">Parameters</a></li><li><a href="#Problems">Problems</a></li><li><a href="#Eigen-solvers">Eigen solvers</a></li><li><a href="#Branch-switching-(branch-point)">Branch switching (branch point)</a></li><li><a href="#Branch-switching-(Hopf-point)">Branch switching (Hopf point)</a></li><li><a href="#Utils-for-periodic-orbits">Utils for periodic orbits</a></li><li><a href="#Misc.">Misc.</a></li></ul></li></ul><h2 id="Parameters"><a class="docs-heading-anchor" href="#Parameters">Parameters</a><a id="Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.NewtonPar" href="#BifurcationKit.NewtonPar"><code>BifurcationKit.NewtonPar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NewtonPar{T, L&lt;:BifurcationKit.AbstractLinearSolver, E&lt;:AbstractEigenSolver}</code></pre><p>Returns a variable containing parameters to affect the <code>newton</code> algorithm when solving <code>F(x) = 0</code>.</p><p><strong>Arguments (with default values):</strong></p><ul><li><p><code>tol::Any</code>: absolute tolerance for <code>F(x)</code> Default: 1.0e-12</p></li><li><p><code>maxIter::Int64</code>: number of Newton iterations Default: 25</p></li><li><p><code>verbose::Bool</code>: display Newton iterations? Default: false</p></li><li><p><code>linsolver::BifurcationKit.AbstractLinearSolver</code>: linear solver, must be <code>&lt;: AbstractLinearSolver</code> Default: DefaultLS()</p></li><li><p><code>eigsolver::AbstractEigenSolver</code>: eigen solver, must be <code>&lt;: AbstractEigenSolver</code> Default: DefaultEig()</p></li><li><p><code>linesearch::Bool</code>: Default: false</p></li><li><p><code>α::Any</code>: Default: convert(typeof(tol), 1.0)</p></li><li><p><code>αmin::Any</code>: Default: convert(typeof(tol), 0.001)</p></li></ul><p><strong>Arguments for line search (Armijo)</strong></p><ul><li><code>linesearch = false</code>: use line search algorithm (i.e. Newton with Armijo&#39;s rule)</li><li><code>α = 1.0</code>: initial value of α (damping) parameter for line search algorithm</li><li><code>αmin  = 0.001</code>: minimal value of the damping <code>alpha</code></li></ul><div class="admonition is-success"><header class="admonition-header">Mutating</header><div class="admonition-body"><p>For performance reasons, we decided to use an immutable structure to hold the parameters. One can use the package <code>Setfield.jl</code> to drastically simplify the mutation of different fields. See the tutorials for examples.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.ContinuationPar" href="#BifurcationKit.ContinuationPar"><code>BifurcationKit.ContinuationPar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">options = ContinuationPar(dsmin = 1e-4,...)</code></pre><p>Returns a variable containing parameters to affect the <code>continuation</code> algorithm used to solve <code>F(x,p) = 0</code>.</p><p><strong>Arguments</strong></p><ul><li><code>dsmin, dsmax</code> are the minimum, maximum arclength allowed value. It controls the density of points in the computed branch of solutions.</li><li><code>ds = 0.01</code> is the initial arclength.</li><li><code>pMin, pMax</code> allowed parameter range for <code>p</code></li><li><code>maxSteps = 100</code> maximum number of continuation steps</li><li><code>newtonOptions::NewtonPar</code>: options for the Newton algorithm</li><li><code>saveToFile = false</code>: save to file. A name is automatically generated or can be defined in <a href="../codim2Continuation/#BifurcationKit.continuation"><code>continuation</code></a>. This requires <code>using JLD2</code>.</li><li><code>saveSolEveryStep::Int64 = 0</code> at which continuation steps do we save the current solution</li><li><code>plotEveryStep = 10</code> at which continuation steps do we plot the current solution</li></ul><p><strong>Handling eigen elements, their computation is triggered by the argument <code>detectBifurcation</code> (see below)</strong></p><ul><li><code>nev = 3</code> number of eigenvalues to be computed. It is automatically increased to have at least <code>nev</code> unstable eigenvalues. To be set for proper  bifurcation detection. See <a href="../detectionBifurcation/#Detection-of-bifurcation-points">Detection of bifurcation points</a> for more informations.</li><li><code>saveEigEveryStep = 1</code>	record eigen vectors every specified steps. <strong>Important</strong> for memory limited resource, <em>e.g.</em> GPU.</li><li><code>saveEigenvectors	= true</code>	<strong>Important</strong> for memory limited resource, <em>e.g.</em> GPU.</li></ul><p><strong>Handling bifurcation detection</strong></p><ul><li><code>tolStability = 1e-10</code> lower bound on the real part of the eigenvalues to test for stability of equilibria and periodic orbits</li><li><code>detectFold = true</code> detect Fold bifurcations? It is a useful option although the detection of Fold is cheap. Indeed, it may happen that there is a lot of Fold points and this can saturate the memory in memory limited devices (e.g. on GPU)</li><li><code>detectBifurcation::Int</code> ∈ {0, 1, 2, 3} If set to 0, nothing is done. If set to 1, the eigen-elements are computed. If set to 2, the bifurcations points are detected during the continuation run, but not located precisely. If set to 3, a bisection algorithm is used to locate the bifurcations points (slower). The possibility to switch off detection is a useful option. Indeed, it may happen that there are a lot of bifurcation points and this can saturate the memory of memory limited devices (e.g. on GPU)</li><li><code>dsminBisection = 1e-16</code> dsmin for the bisection algorithm for locating bifurcation points</li><li><code>nInversion = 2</code> number of sign inversions in bisection algorithm</li><li><code>maxBisectionSteps = 15</code> maximum number of bisection steps</li><li><code>tolBisectionEigenvalue = 1e-16</code> tolerance on real part of eigenvalue to detect bifurcation points in the bisection steps</li></ul><p><strong>Handling <code>ds</code> adaptation (see <a href="../codim2Continuation/#BifurcationKit.continuation"><code>continuation</code></a> for more information)</strong></p><ul><li><code>a  = 0.5</code> aggressiveness factor. It is used to adapt <code>ds</code> in order to have a number of newton iterations per continuation step roughly constant. The higher <code>a</code> is, the larger the step size <code>ds</code> is changed at each continuation step.</li></ul><p><strong>Handling event detection</strong></p><ul><li><code>detectEvent::Int</code> ∈ {0, 1, 2} If set to 0, nothing is done. If set to 1, the event locations are sought during the continuation run, but not located precisely. If set to 2, a bisection algorithm is used to locate the event (slower).</li><li><code>tolParamBisectionEvent = 1e-16</code> tolerance on parameter to locate event</li></ul><p><strong>Misc</strong></p><ul><li><code>η = 150.</code> parameter to estimate tangent at first point with parameter  p₀ + ds / η</li><li><code>detectLoop</code> [WORK IN PROGRESS] detect loops in the branch and stop the continuation</li></ul><div class="admonition is-success"><header class="admonition-header">Mutating</header><div class="admonition-body"><p>For performance reasons, we decided to use an immutable structure to hold the parameters. One can use the package <code>Setfield.jl</code> to drastically simplify the mutation of different fields. See tutorials for more examples.</p></div></div></div></section></article><h2 id="Problems"><a class="docs-heading-anchor" href="#Problems">Problems</a><a id="Problems-1"></a><a class="docs-heading-anchor-permalink" href="#Problems" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DDEBifurcationKit.ConstantDDEBifProblem" href="#DDEBifurcationKit.ConstantDDEBifProblem"><code>DDEBifurcationKit.ConstantDDEBifProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConstantDDEBifProblem{Tvf, Tdf, Tu, Td, Tp, Tl&lt;:Lens, Tplot, Trec, Tδ} &lt;: DDEBifurcationKit.AbstractDDEBifurcationProblem</code></pre><p>Structure to hold the bifurcation problem. If don&#39;t have parameters, you can pass <code>nothing</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>VF::Any</code>: Vector field, typically a <a href="@ref"><code>BifFunction</code></a></p></li><li><p><code>delays::Any</code>: function delays. It takes the parameters and return the non-zero delays in an <code>AsbtractVector</code> form. Example: <code>delays = par -&gt; [1.]</code></p></li><li><p><code>u0::Any</code>: Initial guess</p></li><li><p><code>delays0::Any</code>: initial delays (set internally by the constructor)</p></li><li><p><code>params::Any</code>: parameters</p></li><li><p><code>lens::Lens</code>: Typically a <code>Setfield.Lens</code>. It specifies which parameter axis among <code>params</code> is used for continuation. For example, if <code>par = (α = 1.0, β = 1)</code>, we can perform continuation w.r.t. <code>α</code> by using <code>lens = (@lens _.α)</code>. If you have an array <code>par = [ 1.0, 2.0]</code> and want to perform continuation w.r.t. the first variable, you can use <code>lens = (@lens _[1])</code>. For more information, we refer to <code>SetField.jl</code>.</p></li><li><p><code>plotSolution::Any</code>: user function to plot solutions during continuation. Signature: <code>plotSolution(x, p; kwargs...)</code></p></li><li><p><code>recordFromSolution::Any</code>: <code>recordFromSolution = (x, p) -&gt; norm(x)</code> function used record a few indicators about the solution. It could be <code>norm</code> or <code>(x, p) -&gt; x[1]</code>. This is also useful when saving several huge vectors is not possible for memory reasons (for example on GPU...). This function can return pretty much everything but you should keep it small. For example, you can do <code>(x, p) -&gt; (x1 = x[1], x2 = x[2], nrm = norm(x))</code> or simply <code>(x, p) -&gt; (sum(x), 1)</code>. This will be stored in <code>contres.branch</code> (see below). Finally, the first component is used to plot in the continuation curve.</p></li><li><p><code>δ::Any</code>: delta for Finite differences</p></li></ul><p><strong>Methods</strong></p><ul><li><code>getu0(pb)</code> calls <code>pb.u0</code></li><li><code>getParams(pb)</code> calls <code>pb.params</code></li><li><code>getLens(pb)</code> calls <code>pb.lens</code></li><li><code>getParam(pb)</code> calls <code>get(pb.params, pb.lens)</code></li><li><code>setParam(pb, p0)</code> calls <code>set(pb.params, pb.lens, p0)</code></li><li><code>recordFromSolution(pb)</code> calls <code>pb.recordFromSolution</code></li><li><code>plotSolution(pb)</code> calls <code>pb.plotSolution</code></li><li><code>isSymmetric(pb)</code> calls <code>isSymmetric(pb.prob)</code></li></ul><p><strong>Constructors</strong></p><ul><li><code>ConstantDDEBifProblem(F, delays, u0, params, lens; J, Jᵗ, d2F, d3F, kwargs...)</code> and <code>kwargs</code> are the fields above.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/DDEBifurcationKit.jl/blob/fef4498e12d511a00d9e6fbaa34aab8f58164915/src/Problems.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDEBifurcationKit.SDDDEBifProblem" href="#DDEBifurcationKit.SDDDEBifProblem"><code>DDEBifurcationKit.SDDDEBifProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SDDDEBifProblem{Tvf, Tdf, Tu, Td, Tp, Tl&lt;:Lens, Tplot, Trec, Tδ} &lt;: DDEBifurcationKit.AbstractDDEBifurcationProblem</code></pre><p>Structure to hold the bifurcation problem. If don&#39;t have parameters, you can pass <code>nothing</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>VF::Any</code>: Vector field, typically a <a href="@ref"><code>BifFunction</code></a></p></li><li><p><code>delays::Any</code>: function delays. It takes the parameters and the state and return the non-zero delays in an <code>AsbtractVector</code> form. Example: <code>delays = (par, u) -&gt; [1. + u[1]^2]</code></p></li><li><p><code>u0::Any</code>: Initial guess</p></li><li><p><code>delays0::Any</code>: initial delays (set internally by the constructor)</p></li><li><p><code>params::Any</code>: parameters</p></li><li><p><code>lens::Lens</code>: Typically a <code>Setfield.Lens</code>. It specifies which parameter axis among <code>params</code> is used for continuation. For example, if <code>par = (α = 1.0, β = 1)</code>, we can perform continuation w.r.t. <code>α</code> by using <code>lens = (@lens _.α)</code>. If you have an array <code>par = [ 1.0, 2.0]</code> and want to perform continuation w.r.t. the first variable, you can use <code>lens = (@lens _[1])</code>. For more information, we refer to <code>SetField.jl</code>.</p></li><li><p><code>plotSolution::Any</code>: user function to plot solutions during continuation. Signature: <code>plotSolution(x, p; kwargs...)</code></p></li><li><p><code>recordFromSolution::Any</code>: <code>recordFromSolution = (x, p) -&gt; norm(x)</code> function used record a few indicators about the solution. It could be <code>norm</code> or <code>(x, p) -&gt; x[1]</code>. This is also useful when saving several huge vectors is not possible for memory reasons (for example on GPU...). This function can return pretty much everything but you should keep it small. For example, you can do <code>(x, p) -&gt; (x1 = x[1], x2 = x[2], nrm = norm(x))</code> or simply <code>(x, p) -&gt; (sum(x), 1)</code>. This will be stored in <code>contres.branch</code> (see below). Finally, the first component is used to plot in the continuation curve.</p></li><li><p><code>δ::Any</code>: delta for Finite differences</p></li></ul><p><strong>Methods</strong></p><ul><li><code>getu0(pb)</code> calls <code>pb.u0</code></li><li><code>getParams(pb)</code> calls <code>pb.params</code></li><li><code>getLens(pb)</code> calls <code>pb.lens</code></li><li><code>getParam(pb)</code> calls <code>get(pb.params, pb.lens)</code></li><li><code>setParam(pb, p0)</code> calls <code>set(pb.params, pb.lens, p0)</code></li><li><code>recordFromSolution(pb)</code> calls <code>pb.recordFromSolution</code></li><li><code>plotSolution(pb)</code> calls <code>pb.plotSolution</code></li><li><code>isSymmetric(pb)</code> calls <code>isSymmetric(pb.prob)</code></li></ul><p><strong>Constructors</strong></p><ul><li><code>SDDDEBifProblem(F, delays, u0, params, lens; J, Jᵗ, d2F, d3F, kwargs...)</code> and <code>kwargs</code> are the fields above.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/DDEBifurcationKit.jl/blob/fef4498e12d511a00d9e6fbaa34aab8f58164915/src/Problems.jl#L210">source</a></section></article><h2 id="Eigen-solvers"><a class="docs-heading-anchor" href="#Eigen-solvers">Eigen solvers</a><a id="Eigen-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Eigen-solvers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DDEBifurcationKit.DDE_DefaultEig" href="#DDEBifurcationKit.DDE_DefaultEig"><code>DDEBifurcationKit.DDE_DefaultEig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct DDE_DefaultEig{T, Tw, Tv} &lt;: DDEBifurcationKit.AbstractDDEEigenSolver</code></pre><p>Default eigen solver for DDEBifurcationKit based on the julia package NonlinearEigenproblems.jl. ore precisely, we rely on <code>NonlinearEigenproblems.iar_chebyshev</code> for the computation of eigenvalues.</p><p><strong>Fields</strong></p><ul><li><p><code>maxit::Int64</code>: Default: 100</p></li><li><p><code>which::Any</code>: Default: real</p></li><li><p><code>σ::Any</code>: Default: 0.0</p></li><li><p><code>γ::Any</code>: Default: 1.0</p></li><li><p><code>tol::Any</code>: Default: 1.0e-10</p></li><li><p><code>logger::Int64</code>: Default: 0</p></li><li><p><code>check_error_every::Int64</code>: Default: 1</p></li><li><p><code>v::Any</code>: Default: nothing</p></li></ul><p><strong>Constructors</strong></p><ul><li><code>DDE_DefaultEig(; kwargs...)</code> and <code>kwargs</code> are the fields above.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/DDEBifurcationKit.jl/blob/fef4498e12d511a00d9e6fbaa34aab8f58164915/src/EigSolver.jl#L3">source</a></section></article><h2 id="Branch-switching-(branch-point)"><a class="docs-heading-anchor" href="#Branch-switching-(branch-point)">Branch switching (branch point)</a><a id="Branch-switching-(branch-point)-1"></a><a class="docs-heading-anchor-permalink" href="#Branch-switching-(branch-point)" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>continuation(br::ContResult, ind_bif::Int, optionsCont::ContinuationPar ; kwargs...)</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Branch-switching-(Hopf-point)"><a class="docs-heading-anchor" href="#Branch-switching-(Hopf-point)">Branch switching (Hopf point)</a><a id="Branch-switching-(Hopf-point)-1"></a><a class="docs-heading-anchor-permalink" href="#Branch-switching-(Hopf-point)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.continuation-Tuple{BifurcationKit.AbstractBranchResult, Int64, ContinuationPar, BifurcationKit.AbstractPeriodicOrbitProblem}" href="#BifurcationKit.continuation-Tuple{BifurcationKit.AbstractBranchResult, Int64, ContinuationPar, BifurcationKit.AbstractPeriodicOrbitProblem}"><code>BifurcationKit.continuation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">continuation(
    br,
    ind_bif,
    _contParams,
    probPO;
    alg,
    δp,
    ampfactor,
    usedeflation,
    nev,
    kwargs...
)
</code></pre><p>Perform automatic branch switching from a Hopf bifurcation point labelled <code>ind_bif</code> in the list of the bifurcated points of a previously computed branch <code>br::ContResult</code>. It first computes a Hopf normal form.</p><p><strong>Arguments</strong></p><ul><li><code>br</code> branch result from a call to <code>continuation</code></li><li><code>ind_hopf</code> index of the bifurcation point in <code>br</code></li><li><code>contParams</code> parameters for the call to <code>continuation</code></li><li><code>probPO</code> problem used to specify the way the periodic orbit is computed. It can be <a href="@ref"><code>PeriodicOrbitTrapProblem</code></a>, <a href="@ref"><code>ShootingProblem</code></a> or <a href="@ref"><code>PoincareShootingProblem</code></a> .</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>alg = br.alg</code> continuation algorithm</li><li><code>δp</code> used to specify a particular guess for the parameter on the bifurcated branch which is otherwise determined by <code>contParams.ds</code>. This allows to use a step larger than <code>contParams.dsmax</code>.</li><li><code>ampfactor = 1</code> factor which alter the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.</li><li><code>usedeflation = true</code> whether to use nonlinear deflation (see <a href="@ref">Deflated problems</a>) to help finding the guess on the bifurcated branch</li><li><code>nev</code> number of eigenvalues to be computed to get the right eigenvector</li><li>all <code>kwargs</code> from <a href="../codim2Continuation/#BifurcationKit.continuation"><code>continuation</code></a></li></ul><p>A modified version of <code>prob</code> is passed to <code>plotSolution</code> and <code>finaliseSolution</code>.</p><div class="admonition is-info"><header class="admonition-header">Linear solver</header><div class="admonition-body"><p>You have to be careful about the options <code>contParams.newtonOptions.linsolver</code>. In the case of Matrix-Free solver, you have to pass the right number of unknowns <code>N * M + 1</code>. Note that the options for the preconditioner are not accessible yet.</p></div></div></div></section></article><h2 id="Utils-for-periodic-orbits"><a class="docs-heading-anchor" href="#Utils-for-periodic-orbits">Utils for periodic orbits</a><a id="Utils-for-periodic-orbits-1"></a><a class="docs-heading-anchor-permalink" href="#Utils-for-periodic-orbits" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.getPeriod" href="#BifurcationKit.getPeriod"><code>BifurcationKit.getPeriod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getPeriod(, x)
getPeriod(, x, par)
</code></pre><p>Compute the period of the periodic orbit associated to <code>x</code>.</p></div></section><section><div><pre><code class="language-julia hljs">getPeriod(prob, x, p)
</code></pre><p>Compute the period of the periodic orbit associated to <code>x</code>.</p></div></section><section><div><pre><code class="language-julia hljs">getPeriod(psh, x_bar, par)
</code></pre><p>Compute the period of the periodic orbit associated to <code>x_bar</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.getAmplitude" href="#BifurcationKit.getAmplitude"><code>BifurcationKit.getAmplitude</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getAmplitude(prob, x, p; ratio)
</code></pre><p>Compute the amplitude of the periodic orbit associated to <code>x</code>. The keyword argument <code>ratio = 1</code> is used as follows. If <code>length(x) = 1 + ratio * n</code>, the call returns the amplitude over <code>x[1:n]</code>.</p></div></section><section><div><pre><code class="language-julia hljs">getAmplitude(prob, x, p; ratio)
</code></pre><p>Compute the amplitude of the periodic orbit associated to <code>x</code>. The keyword argument <code>ratio = 1</code> is used as follows. If <code>length(x) = ratio * n</code>, the call returns the amplitude over <code>x[1:n]</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.getMaximum" href="#BifurcationKit.getMaximum"><code>BifurcationKit.getMaximum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getMaximum(prob, x, p; ratio)
</code></pre><p>Compute the maximum of the periodic orbit associated to <code>x</code>. The keyword argument <code>ratio = 1</code> is used as follows. If <code>length(x) = 1 + ratio * n</code>, the call returns the amplitude over <code>x[1:n]</code>.</p></div></section><section><div><pre><code class="language-julia hljs">getMaximum(prob, x, p)
</code></pre><p>Compute the maximum of the periodic orbit associated to <code>x</code>.</p></div></section><section><div><pre><code class="language-julia hljs">getMaximum(prob, x, p; ratio)
</code></pre><p>Compute the maximum of the periodic orbit associated to <code>x</code>. The keyword argument <code>ratio = 1</code> is used as follows. If <code>length(x) = ratio * n</code>, the call returns the amplitude over <code>x[1:n]</code>.</p></div></section></article><h2 id="Misc."><a class="docs-heading-anchor" href="#Misc.">Misc.</a><a id="Misc.-1"></a><a class="docs-heading-anchor-permalink" href="#Misc." title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.guessFromHopf-Tuple{Any, Any, AbstractEigenSolver, Any, Any}" href="#BifurcationKit.guessFromHopf-Tuple{Any, Any, AbstractEigenSolver, Any, Any}"><code>BifurcationKit.guessFromHopf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">guessFromHopf(br, ind_hopf, eigsolver, M, amplitude; phase)
</code></pre><p>This function returns several useful quantities regarding a Hopf bifurcation point. More precisely, it returns:</p><ul><li>the parameter value at which a Hopf bifurcation occurs</li><li>the period of the bifurcated periodic orbit</li><li>a guess for the bifurcated periodic orbit</li><li>the equilibrium at the Hopf bifurcation point</li><li>the eigenvector at the Hopf bifurcation point.</li></ul><p>The arguments are</p><ul><li><code>br</code>: the continuation branch which lists the Hopf bifurcation points</li><li><code>ind_hopf</code>: index of the bifurcation branch, as in <code>br.specialpoint</code></li><li><code>eigsolver</code>: the eigen solver used to find the eigenvectors</li><li><code>M</code> number of time slices in the periodic orbit guess</li><li><code>amplitude</code>: amplitude of the periodic orbit guess</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.getNormalForm" href="#BifurcationKit.getNormalForm"><code>BifurcationKit.getNormalForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getNormalForm(
    prob,
    br,
    id_bif;
    nev,
    verbose,
    ζs,
    lens,
    Teigvec,
    scaleζ,
    detailed,
    autodiff,
    bls
)
</code></pre><p>Compute the normal form of the bifurcation point located at <code>br.specialpoint[ind_bif]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>prob::AbstractBifurcationProblem</code></li><li><code>br</code> result from a call to <a href="../codim2Continuation/#BifurcationKit.continuation"><code>continuation</code></a></li><li><code>ind_bif</code> index of the bifurcation point in <code>br.specialpoint</code></li></ul><p><strong>Optional arguments</strong></p><ul><li><code>nev</code> number of eigenvalues used to compute the spectral projection. This number has to be adjusted when used with iterative methods.</li><li><code>verbose</code> whether to display information</li><li><code>ζs</code> list of vectors spanning the kernel of <code>dF</code> at the bifurcation point. Useful to enforce the basis for the normal form.</li><li><code>lens::Lens</code> specify which parameter to take the partial derivative ∂pF</li><li><code>scaleζ</code> function to normalise the kernel basis. Indeed, when used with large vectors and <code>norm</code>, it results in ζs and the normal form coefficient being super small.</li><li><code>autodiff = true</code> whether to use ForwardDiff for the differentiations w.r.t the parameters that are required to compute the normal form. Used for example for Bogdanov-Takens point. You can set to <code>autodiff = false</code> if you wish.</li><li><code>detailed = true</code> whether to compute only a simplified normal form. Used for example for Bogdanov-Takens point.</li><li><code>bls = MatrixBLS()</code> specify Bordered linear solver. Used for example for Bogdanov-Takens point.</li></ul><p><strong>Available method</strong></p><p>You can directly call </p><pre><code class="nohighlight hljs">getNormalForm(br, ind_bif ; kwargs...)</code></pre><p>which is a shortcut for <code>getNormalForm(getProb(br), br, ind_bif ; kwargs...)</code>.</p><p>Once the normal form <code>nf</code> has been computed, you can call <code>predictor(nf, δp)</code> to obtain an estimate of the bifurcating branch.</p></div></section><section><div><pre><code class="language-julia hljs">getNormalForm(
    prob,
    br,
    id_bif;
    nev,
    verbose,
    ζs,
    lens,
    Teigvec,
    scaleζ,
    prm,
    δ,
    detailed
)
</code></pre><p>Compute the normal form of periodic orbits. Same arguments as the function <code>getNormalForm</code> for equilibria. We detail the additional keyword arguments specific to periodic orbits</p><p><strong>Optional arguments</strong></p><ul><li><code>prm = true</code> compute the normal form using Poincaré return map. For collocation, there will be another way to compute the normal form in the future.</li></ul></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../faq/">« Frequently Asked Questions</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 29 June 2023 09:40">Thursday 29 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
